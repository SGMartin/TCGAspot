#!/usr/bin/env python3
"""
mRNA expression filtering module: This script takes single point mutation data
from the TCGA generated by RNASeq and filters it. At this moment it performs
a quick analysis whose aim is to catch the top overexpressed genes of a patient
compared to the rest of the cohort. It will be used to check cnv gains 
downstream.

An exhaustive analysis will be added later.
"""

import json
import sys

import pandas as pd
import numpy  as np

from scipy import stats
from scipy.stats import zscore

#TODO: Implement an exhaustive filter to tackle multiple transcripts assigned
# to the same gene.
#TODO: Multisampling.
#TODO: Prepare the filter for future annotations.txt file being published

def main(raw_expression_data: str, rna_seq_dict:str, metadata:str, where_to_save:str):

	# Load expr data
	raw_expression_data = pd.read_csv(raw_expression_data,
									  sep='\t',
									  index_col='Ensembl_ID'
									  )

	zscore_filtered   = filter_by_zscore(raw_expression_data)
	absolute_filtered = filter_absolute_values(raw_expression_data)

	filtered_expression = zscore_filtered.append(absolute_filtered, ignore_index=True)
	filtered_expression.drop_duplicates(keep='first', inplace=True)

	expression_annotated_transcripts = filter_known_transcripts(filtered_expression, rna_seq_dict)
	expression_metadata_annotated = annotate_from_metadata(expression_annotated_transcripts, metadata)

	expression_metadata_annotated.to_csv(where_to_save, sep=',', index=False)


def filter_by_zscore(raw_data: pd.DataFrame) -> pd.DataFrame:
	'''
	This method takes input raw expression data and calculates a zscore for
	each transcript across all patients. Transcript with 0 STD are not considered.
	Returns a melted dataframe with aliquots and transcripts whose Zscore is
	above 2
	'''

	# Get STDs as a numpy array. Way faster
	stds  = raw_data.values.std(axis=1)
	
	# Drop entries with 0 STD. Won't be considered.
	invalid_entries = stds.__eq__(0)
	valid_data  	= raw_data[~invalid_entries]

	# Get Z scores
	zscores = zscore(valid_data.values, axis=1)

	zscores = pd.DataFrame(zscores,
						   index=valid_data.index,
						   columns=valid_data.columns
						   )
	
	zscores.reset_index(inplace=True)

	zscores = zscores.melt(id_vars='Ensembl_ID',
						   var_name='aliquot',
						   value_name='zscore')
	
	# Select those over 2
	zscores = zscores[zscores['zscore'] > 2]

	# drop column and return
	zscores.drop('zscore', axis=1, inplace=True)

	del valid_data
	return zscores


def filter_absolute_values(raw_data: pd.DataFrame) -> pd.DataFrame:
	'''
	Filters raw expression data, looking for transcripts whose expression
	value is over 4 for a certain aliquot. Returns a melted dataframe with
	transcripts satisfying the condition.
	'''

	melted_data = raw_data.reset_index().melt(id_vars='Ensembl_ID',
											  var_name='aliquot',
											  value_name='expression'
											  )
	
	melted_data = melted_data[melted_data['expression'] > 4]

	melted_data.drop('expression', axis=1, inplace=True)

	return melted_data


def filter_known_transcripts(melted_data: pd.DataFrame, rna_dict: str):
	'''
	Attempt to match Ensembl_ID transcripts to known genes. Returns a dataframe
	with matched pairs.
	'''
	rna_translation = pd.read_csv(rna_dict, sep=',', index_col='Ensembl_ID')
	rna_translation = rna_translation['Hugo_Symbol'].to_dict()

	# get rid of ensembl version number and attempt the map
	melted_data['Ensembl_ID'] = melted_data['Ensembl_ID'].str.split('.').str[0].str.strip()
	melted_data['Hugo_Symbol'] = melted_data['Ensembl_ID'].map(rna_translation)
	
	# get transcripts which did not match
	melted_data.dropna(axis='index', how='any', inplace=True)

	# Drop Ensembl column, it is not needed anymore
	melted_data.drop('Ensembl_ID', axis=1, inplace=True)

	del rna_translation
	return melted_data


#TODO: refactor this

def annotate_from_metadata(melted_expression: pd.DataFrame, metadata:str) -> pd.DataFrame:
	'''
	Annotates melted expression using metadata. It uses TCGA barcode to extract 
	case_id, aliquot and sample type. Returns melted expression data with case_id,
	sample and aliquot columns.
	'''
	
	# Getting case id from samples
	annotated_cases  = get_case_from_sample(melted_expression, metadata)

	# Get tumor type from barcode
	annotated_cases['sample'] = translate_barcode_to_tumor(annotated_cases['aliquot'])

	# Rename aliquot from barcode to aliquot letter
	annotated_cases['aliquot'] = annotated_cases['aliquot'].str.split('-').str[3].str[2]

	return annotated_cases

def get_case_from_sample(input_expr: pd.DataFrame, metadata: str) -> pd.DataFrame:
	'''
	Translates samples ID to case UUID using metadata. Observations are
	named after alliquots. Returns a dataframe with a new column called
	case_id
	'''
	
	with open(metadata) as metadata_file:
		raw_metadata = json.load(metadata_file)
	
	patient_barcodes = dict()

	for project in raw_metadata:
		for patients in project['associated_entities']:

			trimmed_barcode = patients['entity_submitter_id'].split('-')[0:4]
			trimmed_barcode = '-'.join(trimmed_barcode)
			patient_barcodes[trimmed_barcode] = patients['case_id']
	
	# map is faster than rename for large amounts of data, so we'll use that
	input_expr['case_id'] = input_expr['aliquot'].map(patient_barcodes,
													  na_action='ignore'
													  )	
	del raw_metadata
	return input_expr

def translate_barcode_to_tumor(barcode:str) -> str:
	'''
	Translates tumor barcode to sample type according to
	https://gdc.cancer.gov/resources-tcga-users/tcga-code-tables/sample-type-codes
	'''
	CodesDictionary = {
        "01":"TP",
        "02":"TR",
        "03":"TB",
        "04":"TRBM",
        "05":"TAP",
        "06":"TM",
        "07":"TAM",
        "08":"THOC",
        "09":"TBM",
        "10":"NB",
        "11":"NT",
        "12":"NBC",
        "13":"NEBV",
        "14":"NBM",
        "15":"15SH",
        "16":"16SH",
        "20":"CELLC",
        "40":"TRB",
        "50":"CELL",
        "60":"XP",
        "61":"XCL",
        "99":"99SH"
    }

	sampleCode = str(barcode).split('-')
	doubleDigit = sampleCode[3][0:2]
	
	return CodesDictionary[doubleDigit]


if __name__ == "__main__":
	main(sys.argv[1], sys.argv[2], sys.argv[3], sys.argv[4])	